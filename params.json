{
  "name": "React-native-storage",
  "tagline": "local storage wrapper for both react-native and browser. Support size controlling, auto expiring, remote data auto syncing and getting batch data in one query.",
  "body": "# react-native-storage [![Build Status](https://travis-ci.org/sunnylqm/react-native-storage.svg)](https://travis-ci.org/sunnylqm/react-native-storage)  [![npm version](https://badge.fury.io/js/react-native-storage.svg)](http://badge.fury.io/js/react-native-storage)\r\n\r\nThis is a local storage wrapper for both react-native(AsyncStorage) and browser(localStorage). [ES6](http://babeljs.io/docs/learn-es2015/) syntax, promise for async load, fully tested with jest.\r\n\r\n查看中文文档[请点击README-CHN.md](README-CHN.md)\r\n\r\n## Install\r\n\r\n\tnpm install react-native-storage --save\r\n\r\n## Usage\r\n\r\n### Config\r\n#### For Web\r\nYou need to use [webpack](http://webpack.github.io/) and [babel](https://babeljs.io/) to enable es6 modules for web development.   \r\nYou should add the following lines to your webpack config:  \r\n\r\n```javascript\r\n  // ...\r\n  externals: {\r\n    \"react-native\": {}     // This line is required! Otherwise an error would be thrown.\r\n  },\r\n  module: {\r\n    loaders: [\r\n      // ...\r\n        {\r\n          test: /\\.js?$/,\r\n          include: [\r\n            //path.join(__dirname, 'your-own-js-files'),      \r\n            //path.join(__dirname, 'node_modules/some-other-lib-that-needs-babel'),\r\n            path.join(__dirname, 'node_modules/react-native-storage')\r\n          ],\r\n          loader: 'babel',\r\n          query: {\r\n            cacheDirectory: true,\r\n            presets: ['es2015', 'stage-1', 'react'],\r\n            plugins: ['transform-runtime']\r\n          }\r\n        }\r\n    ]\r\n  }\r\n\r\n```  \r\n\r\n#### For React Native\r\nYou don't have to configure anything(but require react native version >= 0.13).\r\n \r\n\r\n### Import\r\n\r\n```bash\r\nimport Storage from 'react-native-storage';\r\n```  \r\n\r\nDo not use `require('react-native-storage')`, which would cause error in react native version >= 0.16.\r\n\r\n### Init\r\n\r\n```js\r\nvar storage = new Storage({\r\n\t// maximum capacity, default 1000 \r\n\tsize: 1000,    \r\n\t\r\n\t// expire time, default 1 day(1000 * 3600 * 24 secs)\r\n\tdefaultExpires: 1000 * 3600 * 24,\r\n\t\r\n\t// cache data in the memory. default is true.\r\n\tenableCache: true,\r\n\t\r\n\t// if data was not found in storage or expired,\r\n\t// the corresponding sync method will be invoked and return \r\n\t// the latest data.\r\n\tsync : {\r\n\t\t// we'll talk about the details later.\r\n\t}\r\n})\t\r\n\r\n// I suggest you have one(and only one) storage instance in global scope.\r\n\r\n// for web\r\n// window.storage = storage;\r\n\r\n// for react native\r\n// global.storage = storage;\r\n```\r\n\r\n### Save & Load & Remove\r\n\r\n```js\r\n// Save something with key only. \r\n// Something more unique, and constantly being used.\r\n// They are perminently stored unless you remove.\r\n// Even expires, the data won't be removed. Only sync method would be invoked.\r\nstorage.save({\r\n\tkey: 'loginState',   // Note: Do not use underscore(\"_\") in key!\r\n\trawData: { \r\n\t\tfrom: 'some other site',\r\n\t\tuserid: 'some userid',\r\n\t\ttoken: 'some token'\r\n\t},\r\n\t\r\n\t// if not specified, the defaultExpires will be applied instead.\r\n\t// if set to null, then it will never expires.\r\n\texpires: 1000 * 3600\r\n});\r\n\r\n// load\r\nstorage.load({\r\n\tkey: 'loginState',\r\n\t\r\n\t// autoSync(default true) means if data not found or expired,\r\n\t// then invoke the corresponding sync method\r\n\tautoSync: true,\r\n\t\r\n\t// syncInBackground(default true) means if data expired,\r\n\t// return the outdated data first while invoke the sync method.\r\n\t// It can be set to false to always return data provided by sync method when expired.(Of course it's slower)\r\n\tsyncInBackground: true\r\n}).then( ret => {\r\n\t// found data goes to then()\r\n\tconsole.log(ret.userid);\r\n}).catch( err => {\r\n\t// any exception including data not found \r\n\t// goes to catch()\r\n\tconsole.warn(err);\r\n})\r\n\r\n// --------------------------------------------------\r\n\r\n// Save something with key and id. Something of the same type(key). \r\n// There is a quota over \"key-id\" data(the size parameter you pass in constructor).\r\n// By default the 1001th data will overwrite the 1st data. \r\n// If you then load the 1st data, a catch(data not found) or sync will be invoked.\r\nvar userA = {\r\n\tname: 'A',\r\n\tage: 20,\r\n\ttags: [\r\n\t\t'geek',\r\n\t\t'nerd',\r\n\t\t'otaku'\r\n\t]\r\n};\r\n\r\nstorage.save({\r\n\tkey: 'user',  // Note: Do not use underscore(\"_\") in key!\r\n\tid: '1001',\t  // Note: Do not use underscore(\"_\") in id!\t\r\n\trawData: userA,\r\n\texpires: 1000 * 60\t \r\n});\r\n\r\n// load\r\nstorage.load({\r\n\tkey: 'user'\r\n\tid: '1001'\r\n}).then( ret => {\r\n\t// found data goes to then()\r\n\tconsole.log(ret.userid);\r\n}).catch( err => {\r\n\t// any exception including data not found \r\n\t// goes to catch()\r\n\tconsole.warn(err);\r\n})\r\n\r\n// --------------------------------------------------  \r\n\r\n//remove single record\r\nstorage.remove({\r\n\tkey: 'lastPage'\r\n});\r\nstorage.remove({\r\n\tkey: 'user'\r\n\tid: '1001'\r\n});\r\n\r\n//!! clear map and remove all key-id data (but keep the key-only data)\r\nstorage.clearMap();\r\n```\r\n\r\n### Sync remote data(refresh)\r\nYou can pass sync methods as one object parameter to the storage constructor, but also you can add it any time.\r\n\r\n```js\r\nstorage.sync = {\r\n\r\n\t// The name of the sync method must be the same of the data's key\r\n\t// And the passed params will be an all-in-one object.\r\n\t// You can use promise here. \r\n\t// Or plain callback function with resolve/reject, like:\r\n\tuser(params){\r\n\t\tlet { id, resolve, reject } = params;\r\n\t\tfetch('user/', {\r\n\t\t\tmethod: 'GET',\r\n\t\t\tbody: 'id=' + id\r\n\t\t}).then( response => {\r\n\t\t\treturn response.json();\r\n\t\t}).then( json => {\r\n\t\t\t// console.log(json);\r\n\t\t\tif(json && json.user){\r\n\t\t\t\tstorage.save({\r\n\t\t\t\t\tkey: 'user',\r\n\t\t\t\t\tid,\r\n\t\t\t\t\trawData: json.user\r\n\t\t\t\t});\r\n\t\t\t\t// Call resolve() when succeed\r\n\t\t\t\tresolve && resolve(json.user);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t// Call reject() when failed\r\n\t\t\t\treject && reject('data parse error');\r\n\t\t\t}\r\n\t\t}).catch( err => {\r\n\t\t\tconsole.warn(err);\r\n\t\t\treject && reject(err);\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\nWith this example sync method, when you invoke:    \r\n\r\n```js\r\nstorage.load({\r\n\tkey: 'user',\r\n\tid: '1002'\r\n}).then(...)\r\n```\r\n\r\nIf there is no user 1002 stored currently, then storage.sync.user would be invoked to fetch remote data and returned.    \r\n\r\n### Load batch data\r\n\r\n```js\r\n// Load batch data with the same parameters as storage.load, but in an array.\r\n// It will invoke sync methods on demand, \r\n// and finally return them all in an ordered array.\r\n\r\nstorage.getBatchData([\r\n\t{ key: 'loginState' },\r\n\t{ key: 'checkPoint', syncInBackground: false },\r\n\t{ key: 'balance' },\r\n\t{ key: 'user', id: '1009' }\r\n])\r\n.then( results => {  \r\n\tresults.forEach( result => {\r\n\t\tconsole.log(result); \r\n\t})\r\n})\r\n\r\n// Load batch data with one key and an array of ids.\r\nstorage.getBatchDataWithIds({\r\n\tkey: 'user', \r\n\tids: ['1001', '1002', '1003']\r\n})\r\n.then( ... )\r\n```\r\n\r\nThere is a notable difference between the two methods except the arguments. **getBatchData** will invoke different sync methods(since the keys may be different) one by one when corresponding data is missing. However, **getBatchDataWithIds** will collect missing data, push their ids to an array, then pass the array to the corresponding sync method(to avoid too many requests) once, so you need to implement array query on server end and handle the parameters of sync method properly(cause the id parameter can be a single string or an array of strings).    \r\n\r\n####You are welcome to ask any question in the [issues](https://github.com/sunnylqm/react-native-storage/issues) page. \r\n\r\n### Changelog\r\n\r\n#### 0.0.16\r\n1. getBatchDataWithIds now won't invoke sync if everything is ready in storage.\r\n\r\n#### 0.0.15\r\n1. Fix bugs in promise chain.\r\n2. Can be used without any storage backend.(Use in-memory map)\r\n\r\n#### 0.0.10  \r\n1. All methods except remove and clearMap are now totally promisified. Even custom sync methods can be promise. So you can chain them now. \r\n2. Adjust map structure.\r\n3. Improved some test cases.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}